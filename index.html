<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"qingjiu.life",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"right",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta property="og:type" content="website"><meta property="og:title" content="青酒的代码馆"><meta property="og:url" content="https://qingjiu.life/index.html"><meta property="og:site_name" content="青酒的代码馆"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="青酒"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://qingjiu.life/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>青酒的代码馆</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">青酒的代码馆</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">浩瀚书海是我的归宿</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">27</span></a></li></ul></nav></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/Vim%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/Vim%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html" class="post-title-link" itemprop="url">Vim常用指令</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 16:00:00 / 修改时间：08:46:15" itemprop="dateCreated datePublished" datetime="2022-03-14T16:00:00+08:00">2022-03-14</time></span></div></header><div class="post-body" itemprop="articleBody"><p>常用命令</p><blockquote><ul><li>使用f{char}移动到char字符上，t移动到前一个字符。如果第一次没搜到可用分号（；）或逗号（，）继续搜索；F反过来搜索前面的char</li><li>u 撤销undo,&lt;Ctrl+r&gt; redo</li><li>zc 折叠，zC折叠所有嵌套；zo展开折叠，zO展开所有折叠</li><li>!shell 执行外部命令</li><li># 可以快速搜索本字符&#x2F;单词</li></ul></blockquote><h3 id="普通模式："><a href="#普通模式：" class="headerlink" title="普通模式："></a>普通模式：</h3><ol><li>快速移动</li></ol><ul><li>跳到第n行在命令模式下执行</li><li>数字+h&#x2F;j&#x2F;k&#x2F;l 实现向左&#x2F;下&#x2F;上&#x2F;右移动”数字”次</li><li>gi 快速回到最后一次编辑的位置，并切换到插入模式移动</li><li>w&#x2F;e移到下一个word&#x2F;WORD开头。e&#x2F;E移到下一个word&#x2F;WORD结尾</li><li>b&#x2F;B上一个word&#x2F;WORD开头，background</li><li>word指以非空白符分割的字符，WORD指以空白符分割的字符</li><li>使用f{char}移动到char字符上，t移动到前一个字符。如果第一次没搜到可用分号（；）或逗号（，）继续搜索；F反过来搜索前面的char</li><li>0和^移动到行首，$移动到行尾，g_移动到行尾非空白字符</li><li>（），{}在句子间、段落间移到</li></ul><ol start="2"><li>页面移动</li></ol><ul><li><p>gg&#x2F;G移动到文件开头和结尾，ctrl+快速返回</p></li><li><p>H&#x2F;M&#x2F;L跳转到屏幕的开头、中间、结尾</p></li><li><p>ctrl+u下翻页，zz将当前行显示在中间</p><ul><li><p>增删改查</p><blockquote><p>增：</p></blockquote><ul><li>切换到插入模式i(insert),a(append),o(open in new line)，A（在行尾插入）I（在行首插入）O（在上一行插入）</li><li>gi 快速回到最后一次编辑的位置，并切换到插入模式</li></ul><blockquote><p>删：</p></blockquote><ul><li>x&#x2F;d，都<strong>可以搭配数字</strong>来执行多少次</li><li>dw（删除单词：从光标到下个单词开始的范围内），diw（删除整个单词不包含空白字符），daw（delete around word，删除单词并包含它周围的空格）</li><li>dd 删除当前行</li><li>D删除当前行所有内容，只留下一个空行</li><li>dt+) ：delete to )删除字符直到)</li><li>d0 删到下行行首</li><li>d$ 删到行尾</li></ul><blockquote><p>改：</p></blockquote><ul><li>r（replace，更改一个char），c（change，配合文本对象进行快速修改），s（substitute，删除该字符并进入编辑模式，可以数字+s）</li><li>R（不断替换下一个字符），S（删除该行字符并进入编辑模式）</li><li>cw（删除该单词并插入），caw，ciw，ct+char</li></ul><blockquote><p>查：</p></blockquote><ul><li>使用&#x2F;或？进行前向&#x2F;反向搜索</li><li>使用n&#x2F;N跳转到下一个&#x2F;上一个匹配</li><li>使用*&#x2F;#进行当前单词的前向&#x2F;后向匹配zo</li></ul></li><li><p>文本对象 [number]<command>[text object]</command></p><ul><li>number:次数</li><li>command: d(delete),c(change),y(yank),v(view,可以以这种规则去选择单词、句子或段落)</li><li>text object:w(word),s(sentence),p(paragraph)</li><li>iw表示inner word,aw表示a word,它不但会选中当前单词，还会包含当前单词之后的空格。同理，is,as,ip,ap。</li></ul></li><li><p>复制粘贴</p><ul><li>y(yank)、p(put)</li><li>yy 复制一行，yiw,yis,yip.</li></ul></li></ul></li></ul><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><ul><li>ctr l+h删除上一个字符</li><li>ctrl+w删除上一个单词</li><li>ctrl+u删除当前行</li><li>ctrl+t正行对齐（tab）</li></ul><h3 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h3><ul><li>普通模式下按 v 、V、ctrl+v</li><li>选中后按u&#x2F;U 切换大小写</li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul><li><p>e(edit) filename 打开文件</p></li><li><p>vs(vertical split)，:sp(split) 分屏</p></li><li><p>set nu 显示行号</p></li><li><p>:n 跳到第n行</p></li><li><p>reg 打开寄存器栏</p></li><li><p>:set autoindent 设置自动缩进(在编写代码时可以使用，但是粘贴python代码会有缩进错乱的问题)</p></li><li><p>:set paste,:set nopaste 解决上述问题</p></li><li><p>res 应该是reset,重置界面</p></li><li><p>% s&#x2F;foo&#x2F;bar&#x2F;g （%：全部文件，s:替换，foo-&gt;bar，g:全局）全局替换</p></li><li><p>q 退出当前文件</p></li><li><p>syntax on（语法标亮，应该需要插件）</p></li><li><p>set hls（highlight search） 将搜索内容高亮</p></li><li><p>set incsearch 增量搜索</p></li><li><p>搜索替换 [range]s[ubstitute]&#x2F;{pattern}&#x2F;{string}&#x2F;[flags]</p><blockquote><p>range 表示范围，比如：10，20表示10-20行，%表示全部；<br>pattern是要替换的模式<br>string是替换后的文本</p><p>flags:</p><ul><li>g(global)表示全局范围内执行</li><li>c(confirm)表示确认，可以确认或者拒绝修改</li><li>n(number)报告匹配到的次数而不替换，可以用来查询匹配次数</li></ul></blockquote></li><li><p>set expandtab 此配置使得在Vim插入模式下按下 Tab 键时，输入到Vim中的都是空格</p></li><li><p>多文件操作</p><blockquote><p>Buffer</p></blockquote><p>​ :ls 列举当前缓冲区</p><p>​ :b n 跳转到第n个缓冲区</p><p>​ :bpre， :bnext， :bfirst， :blast</p><p>​ :b buffer_name 可以使用tab补全</p><blockquote><p>Window</p></blockquote><ul><li>窗口切换<ul><li>&lt;Ctrl+w&gt;w&#x2F;W 在窗口间循环切换</li><li>&lt;Ctrl+w&gt;k&#x2F;K 切换到上边的窗口</li><li>&lt;Ctrl+w&gt;j&#x2F;J 切换到下边的窗口</li><li>&lt;Ctrl+w&gt;h&#x2F;H 切换到左边的窗口</li><li>&lt;Ctrl+w&gt;l&#x2F;L 切换到右边的窗口</li></ul></li></ul><ul><li>重排窗口<ul><li>&lt;Ctrl+w&gt;&#x3D; 适应化所有窗口</li><li>&lt;Ctrl+w&gt;_ 最大化当前窗口的高度</li><li>&lt;Ctrl+w&gt;| 最大化当前窗口的宽度</li><li>[n]&lt;Ctrl+w&gt;_ 当前活动窗口的高度调整为n行</li><li>[n]&lt;Ctrl+w&gt;| 当前活动窗口的宽度调整为n列</li></ul></li></ul><blockquote><p>Table</p></blockquote><ul><li>tabnew tab_name 打开一个名为tab_name的新的标签页</li><li>gt 在标签页间切换</li></ul></li><li><p>VIM更换配色</p><ul><li>:colorschme 显示当前主题配色</li><li>:colorscheme &lt;Ctrl+d&gt; 显示所有配色</li><li>:colorscheme 配色名 修改配色</li><li>注意neovim的配置文件在init.vim下（vim的配置文件名字是vimrc）</li></ul></li><li><p>批量操作</p><ul><li>VIM宏使用流程<ol><li>{command}:qa &#x2F;&#x2F;开始录制,并将动作记录到寄存器a中，a可以更改为a-z中的任意一个</li><li>{normal}选择某一行进行操作</li><li>{command}:q &#x2F;&#x2F;取消录制</li><li>{view}选中需要执行该宏的行</li><li>{command}:normal @a &#x2F;&#x2F;执行宏</li></ol></li><li>Normal命令批量操作<ol><li>选中需要操作的行</li><li>{command}:normal 命令集<br>比如，normal A” ，这句话的意思就是在所选行的每行末尾添加双引号。</li></ol></li></ul></li><li><p>补全方式</p><ul><li><p>自带补全命令</p><table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">Ctrl+n</td><td align="left">普通关键字</td></tr><tr><td align="left">Ctrl+x Ctrl+n</td><td align="left">当前缓冲区关键字</td></tr><tr><td align="left">Ctrl+x Ctrl+i</td><td align="left">包含文件关键字</td></tr><tr><td align="left">Ctrl+x Ctrl+]</td><td align="left">标签文件关键字</td></tr><tr><td align="left">Ctrl+x Ctrl+k</td><td align="left">字典查找</td></tr><tr><td align="left">Ctrl+x Ctrl+l</td><td align="left">整行补全</td></tr><tr><td align="left">Ctrl+x Ctrl+f</td><td align="left">文件名补全</td></tr><tr><td align="left">Ctrl+x Ctrl+o</td><td align="left">全能补全</td></tr></tbody></table></li><li><p>常见类型</p><ul><li>补全单词：ctrl+n，ctrl+p</li><li>补全文件名：ctrl+x ctrl+f</li><li>代码补全：ctrl+x ctrl+o ，开启代码补全需要开启类型检查，安装插件</li></ul></li></ul></li></ul><h3 id="vim进阶"><a href="#vim进阶" class="headerlink" title="vim进阶"></a>vim进阶</h3><p>重要命令</p><ul><li>let $变量名&#x3D;”path” 给变量赋值，便于打开文件</li><li>echo $变量名 查看变量映射的地址（一些默认变量：$VIM,$HOME）</li><li>stdpath(‘config’)配置文件的路径；stdpath(‘data’)数据文件的路径；stdpat(‘cache’)</li><li>scriptnames 查看加载时加载了那些vim脚本</li><li>source fileName 将该文件作为配置文件;source % ,Flush by current file</li></ul><p>Important Knowledge</p><h4 id="vim-profile"><a href="#vim-profile" class="headerlink" title="vim profile"></a>vim profile</h4><p>If use Neovim,<br>the profile should be set neovim&#x2F;share&#x2F;nvim&#x2F;sysinit.vim .</p><p>If use vim,<br>the profile should be set $HOME&#x2F;.vim&#x2F;vimrc .</p><h4 id="vim-map"><a href="#vim-map" class="headerlink" title="vim map"></a>vim map</h4><p>Mode-specific maps</p><ul><li>Normal</li><li>Visual</li><li>Insert</li><li>Command-line</li><li>Operator pending</li></ul><p>Some arguments:</p><blockquote><p>“nore”:no recursive</p></blockquote><p>Some commands:</p><blockquote><p>map<br>imap,nmap,vmap,xmap,omap</p></blockquote><h4 id="vimscript"><a href="#vimscript" class="headerlink" title="vimscript"></a>vimscript</h4><blockquote><p>h options-list 查看可用命令<br>推荐一本书《笨方法学VimScript》</p></blockquote><h4 id="vim-plugin"><a href="#vim-plugin" class="headerlink" title="vim plugin"></a>vim plugin</h4><blockquote><p>常见的插件管理器：<strong>vim-plug</strong>,Vundle,Pathogen,Deiv.Vim,volt<br><strong>vim-plug Commands:</strong> Pluginstall,PlugStatus,PlugClean,PlugUpdate</p></blockquote><p>Good Plugins:</p><blockquote><p>plug “plugin manager”<br>airline<br>airline-theme<br>starify<br>molokai “a theme on vim”<br>nerdtree<br>markdown-preview</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/Linux%E5%AD%A6%E4%B9%A0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/Linux%E5%AD%A6%E4%B9%A0.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-10 11:31:43" itemprop="dateModified" datetime="2022-03-10T11:31:43+08:00">2022-03-10</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="安装nginx的bug记录及修复全过程"><a href="#安装nginx的bug记录及修复全过程" class="headerlink" title="安装nginx的bug记录及修复全过程"></a>安装nginx的bug记录及修复全过程</h2><h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><p>安装好nginx和php后，需要在nginx.conf中配置server语句块，但是该congf中不存在此句块。然后使用指令：grep -rn “server” * ,查到在avaliable&#x2F;default下。</p><p>service</p><p>systemctl</p><p>数据库名：welcome<br>数据库用户名：qingjiu<br>数据库密码：L*******.<br>数据库主机：localhost(47.97.***.**)<br>数据库表前缀：wl*</p><h3 id="bug1"><a href="#bug1" class="headerlink" title="bug1"></a>bug1</h3><p>期间发生生了一个难以解决的问题，耽误了我进三个小时：<br>能够进入网站，但是必须手动在后面添加index.php才能进去。</p><p>原因是sites-enabled&#x2F;default中的配置问题，具体哪一个不清楚，但反复修改四五遍。</p><p>然后修改次数太多，多次service nginx reload ，导致必须重启服务才能OK。</p><p>期间修改default的时候无意间把主机地址改掉了，许久没有发现，也是一个重要原因。<br>其次，进入网站后有许多问题，我重新安装了wordpress，换了个全英的，不要汉化的。</p><h3 id="bug2"><a href="#bug2" class="headerlink" title="bug2"></a>bug2</h3><p>背景：</p><blockquote><p>先前安装php和mysql的时候没有考虑版本问题，所以安装的是php7.1，后来想安装某个插件，提示需要php7.4以上，于是安装了php8.0。</p></blockquote><p>问题：</p><blockquote><p>安装php8.0之后发现，php连接不上数据库了，报错显示找不到mysql扩展。最初的想法是安装php8.0后ini中的内容没有修改（觉得php7.1和mysql先后安装的时候，mysql会将php.ini自动修改。自己重新安装php8.0后ini没办法自动修改，所以觉得是ini配置的问题，我真傻）。</p></blockquote><p>解决路线：</p><blockquote><p>原先是各种该ini，再reload nginx ，service ** restart。丝毫没有逻辑，想一出是一出。后来冷静下来，查看一下php7.1的ini配置，发现和php8.1的ini是一摸一样的（就是extension&#x3D;mysqli这一行都被注释掉了）。所以，认为连接mysqli不是通过ini来实现的。后来，发现了一个指令<br>“apt install php-mysql”。重新安装了php-install，安装的时候注意到有8.0等字样，成功。</p></blockquote><h2 id="ftp服务器相关"><a href="#ftp服务器相关" class="headerlink" title="ftp服务器相关"></a>ftp服务器相关</h2><h3 id="匿名服务anonymous"><a href="#匿名服务anonymous" class="headerlink" title="匿名服务anonymous"></a>匿名服务anonymous</h3><p><a target="_blank" rel="noopener" href="http://www.east263.com/news/server/FTPServer/2019-10-23/1964.html">ftp常见报错之Use PORT or PASV first解决思路和方法</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/halberd-lee/p/11734363.html">vsftpd 常用功能参数配置及参数详解</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="新机器、新环境"><a href="#新机器、新环境" class="headerlink" title="新机器、新环境"></a>新机器、新环境</h3><h4 id="安装和卸载软件"><a href="#安装和卸载软件" class="headerlink" title="安装和卸载软件"></a>安装和卸载软件</h4><p><a target="_blank" rel="noopener" href="https://dlonng.com/posts/linux-install-soft">Linux系统基础-在Linux上安装软件的3种方式</a></p><pre><code>通过apt-get安装，常用命令：
sudo apt-get update:从网上的源更新安装包信息  
sudo apt-get upgrade:升级软件包到最新版本     
sudo apt-get -f install：修复软件依赖包的关系     
sudo apt-get install software_name     
sudo apt-get remove software_name：卸载软件，卸载不完全     
sudo apt-get remove --purge software：常用卸载方式，卸载完全   
</code></pre><h4 id="更改主机名"><a href="#更改主机名" class="headerlink" title="更改主机名"></a>更改主机名</h4><pre><code>vi /etc/hostname
reboot
</code></pre><h4 id="如果是第一次安装系统需要更新apt"><a href="#如果是第一次安装系统需要更新apt" class="headerlink" title="如果是第一次安装系统需要更新apt"></a>如果是第一次安装系统需要更新apt</h4><pre><code>apt update
</code></pre><h4 id="安装PPA"><a href="#安装PPA" class="headerlink" title="安装PPA"></a>安装PPA</h4><pre><code>apt-get install software-properties-common
</code></pre><h4 id="安装neovim"><a href="#安装neovim" class="headerlink" title="安装neovim"></a>安装neovim</h4><pre><code>sudo apt neovim
</code></pre><h4 id="更改admin用户密码为123456"><a href="#更改admin用户密码为123456" class="headerlink" title="更改admin用户密码为123456"></a>更改admin用户密码为123456</h4><pre><code>sudo passwd admin
123456
123456
</code></pre><h4 id="从windows编辑的sysinit-vim文件要注意使用下面这个语句更改一下"><a href="#从windows编辑的sysinit-vim文件要注意使用下面这个语句更改一下" class="headerlink" title="从windows编辑的sysinit.vim文件要注意使用下面这个语句更改一下"></a>从windows编辑的sysinit.vim文件要注意使用下面这个语句更改一下</h4><pre><code>:w ++ff=unix
</code></pre><h4 id="文件夹内容批量移动"><a href="#文件夹内容批量移动" class="headerlink" title="文件夹内容批量移动"></a>文件夹内容批量移动</h4><pre><code>cp -r config/config/. config/
</code></pre><h4 id="更改命令行样式"><a href="#更改命令行样式" class="headerlink" title="更改命令行样式"></a>更改命令行样式</h4><pre><code>nvim ~/.bashrc
</code></pre><h3 id="压缩包命令"><a href="#压缩包命令" class="headerlink" title="压缩包命令"></a>压缩包命令</h3><h4 id="tar"><a href="#tar" class="headerlink" title=".tar"></a>.tar</h4><pre><code>解包：tar xvf FileName.tar    
打包：tar cvf FileName.tar DirName    
</code></pre><p>（注：tar是打包，不是压缩！）</p><h4 id="gz"><a href="#gz" class="headerlink" title=".gz"></a>.gz</h4><pre><code>解压1：gunzip FileName.gz     
解压2：gzip -d FileName.gz    
压缩：gzip FileName   
</code></pre><h4 id="tar-gz-和-tgz"><a href="#tar-gz-和-tgz" class="headerlink" title=".tar.gz 和 .tgz"></a>.tar.gz 和 .tgz</h4><pre><code>解压：tar zxvf FileName.tar.gz        
压缩：tar zcvf FileName.tar.gz DirName    
</code></pre><h3 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h3><h4 id="lsof-list-open-files"><a href="#lsof-list-open-files" class="headerlink" title="lsof(list open files)"></a>lsof(list open files)</h4><p>是一个列出当前系统打开文件的工具。</p><p>lsof 查看端口占用语法格式：</p><pre><code>lsof -i:端口号
</code></pre><p>更多 lsof 的命令如下：</p><pre><code>lsof -i:8080：查看8080端口占用
lsof abc.txt：显示开启文件abc.txt的进程 
lsof -c abc：显示abc进程现在打开的文件
lsof -c -p 1234：列出进程号为1234的进程所打开的文件 
lsof -g gid：显示归属gid的进程情况 
lsof +d /usr/local/：显示目录下被进程开启的文件 
lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长 
lsof -d 4：显示使用fd为4的进程 
lsof -i -U：显示所有打开的端口和UNIX domain文件
</code></pre><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>netstat -tunlp 用于显示 tcp，udp 的端口和进程等相关情况。</p><p>netstat 查看端口占用语法格式：</p><pre><code>netstat -tunlp | grep 端口号
</code></pre><ul><li><p>-t (tcp) 仅显示tcp相关选项</p></li><li><p>-u (udp)仅显示udp相关选项</p></li><li><p>-n 拒绝显示别名，能显示数字的全部转化为数字</p></li><li><p>-l 仅列出在Listen(监听)的服务状态</p></li><li><p>-p 显示建立相关链接的程序名<br>更多命令：</p><pre><code>netstat -ntlp //查看当前所有tcp端口 
netstat -ntulp | grep 80  //查看所有80端口使用情况 
netstat -ntulp | grep 3306  //查看所有3306端口使用情况
</code></pre></li></ul><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>在查到端口占用的进程后，如果你要杀掉对应的进程可以使用 kill 命令：</p><pre><code>kill -9 PID
</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="查找含有某字符串的所有文件"><a href="#查找含有某字符串的所有文件" class="headerlink" title="查找含有某字符串的所有文件"></a>查找含有某字符串的所有文件</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/BabyFish13/article/details/79709028">Linux中grep查找含有某字符串的所有文件</a></p><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>参见csdn文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37138008/article/details/72814543">条件判断:if else 等</a></p><h4 id="更改字体颜色"><a href="#更改字体颜色" class="headerlink" title="更改字体颜色"></a>更改字体颜色</h4><p>参见csdn文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/David_Dai_1108/article/details/70478826">更改输出文本颜色及背景色、闪烁等</a></p><h4 id="echo打印换行"><a href="#echo打印换行" class="headerlink" title="echo打印换行"></a>echo打印换行</h4><p>参见csdn文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jibing57/article/details/7476167">打印换行的方法：-e</a></p><h4 id="比较大小（浮点数和整数）"><a href="#比较大小（浮点数和整数）" class="headerlink" title="比较大小（浮点数和整数）"></a>比较大小（浮点数和整数）</h4><p>参见csdn文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/david__peng/article/details/82980288">shell 数值比大小</a></p><h4 id="定时任务——crontab"><a href="#定时任务——crontab" class="headerlink" title="定时任务——crontab"></a>定时任务——crontab</h4><p>参见简书文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/838db0269fd0">Linux之crontab定时任务</a></p><h4 id="获取系统时间并格式化"><a href="#获取系统时间并格式化" class="headerlink" title="获取系统时间并格式化"></a>获取系统时间并格式化</h4><p>参见csdn文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_29100331/article/details/79091323">shell获取系统当前时间并格式化</a></p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>参见文章：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1114.html">Shell字符串拼接（连接、合并）</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/Java.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/Java.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-10 11:31:43" itemprop="dateModified" datetime="2022-03-10T11:31:43+08:00">2022-03-10</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Java技巧"><a href="#Java技巧" class="headerlink" title="Java技巧"></a>Java技巧</h3><h4 id="1-修改String类型的值"><a href="#1-修改String类型的值" class="headerlink" title="1. 修改String类型的值"></a>1. 修改String类型的值</h4><p>两个方法：</p><p>第一个方法，使用StringBuilder。</p><p>第二个方法，String是引用类型数据，地址不可变，但值可变。String没有对外提供相应的方法来更改值，通过反射可以实现。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> s.getClass();</span><br><span class="line"><span class="comment">//需要使用getDeclaredField(), getField()只能获取公共成员字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clz.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] ch =(<span class="type">char</span>[])field.get(s);</span><br><span class="line">ch[<span class="number">1</span>] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p><u>关于Unicode字符，</u></p><p>Unicode escape sequences may be used elsewhere in a program (such as in field names, for example), not just in <code>char</code> or <code>String</code> literals.</p><p><u>关于转义字符，</u></p><p>The Java programming language supports a few special escape sequences for <code>char</code> and <code>String</code> literals: <code>\b</code> (backspace), <code>\t</code> (tab), <code>\n</code> (line feed), <code>\f</code> (form feed), <code>\r</code> (carriage return), <code>\&quot;</code> (double quote), <code>\&#39;</code> (single quote), and <code>\\</code> (backslash).</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><u>Java中的数组拷贝，</u></p><p>The <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html"><code>System</code></a> class has an <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#arraycopy(java.lang.Object,int,java.lang.Object,int,i)"><code>arraycopy()</code></a> method that you can use to efficiently copy data from one array into another:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos,</span></span><br><span class="line"><span class="params">                             Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure><p>The two <code>Object</code> arguments specify the array to copy from and the array to copy to. The three <code>int</code> arguments specify the starting position in the source array, the starting position in the destination array, and the number of array elements to copy.</p><p>数组操作，</p><h3 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h3><p>详情参见官方文档《<a target="_blank" rel="noopener" href="https://dev.java/learn/annotations/">Annotations</a>》。文档包括以下内容：</p><p>简介，注解的使用格式，注解的使用位置（classes, fields, methods, and other program elements），如何声明一个注解类型，预定义的注解类型（the Java Language，Other Annotations），注解的重复使用，Type Annotations and Pluggable Type Systems。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-10 11:31:43" itemprop="dateModified" datetime="2022-03-10T11:31:43+08:00">2022-03-10</time></span></div></header><div class="post-body" itemprop="articleBody"></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-01-07 10:47:31" itemprop="dateModified" datetime="2022-01-07T10:47:31+08:00">2022-01-07</time></span></div></header><div class="post-body" itemprop="articleBody"><pre><code>说明：
本笔记主要记录分析了Java技术体系中那些最基础、最重要特性的实现原理。
使用的是周志华教授编著的《深入理解Java虚拟机》。    
©qingjiu
</code></pre><h2 id="第一部分-走进Java"><a href="#第一部分-走进Java" class="headerlink" title="第一部分 走进Java"></a>第一部分 走进Java</h2><h3 id="1-走进Java"><a href="#1-走进Java" class="headerlink" title="1. 走进Java"></a>1. 走进Java</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>Java是一个由一系列计算机软件和规范组成的技术体系。</p><p>Java的优点：</p><ul><li>结构严谨、面向对象</li><li>摆脱了硬件平台的束缚，实现“一次编写，到处运行”</li><li>提供了一种相对安全的内存管理和访问机制，避免了绝大多数的内存泄漏和指针越界的问题</li><li>实现了热点代码检测和运行时编译及优化</li><li>有一套完善的应用程序接口，及无数第三方类库帮助用户实现各种功能</li></ul><blockquote><p><strong>【灵感】<br>作为一名Java程序员，在编写程序时除了尽情发挥Java各种优势外，还会情不自禁地想去了解和思考Java技术体系中这些优秀的技术特性是如何出现及怎样实现的，认识这些技术运行的本质。</strong></p></blockquote><h4 id="1-2-Java技术体系"><a href="#1-2-Java技术体系" class="headerlink" title="1.2 Java技术体系"></a>1.2 Java技术体系</h4><p>按各个组成部分的功能来划分，包含以下几部分：</p><ul><li>Java程序设计语言</li><li>各种硬件平台上的Java虚拟机实现</li><li>【❓】Class文件格式</li><li>【❓】Java类库API</li><li>来自商业机构和开源社区的第三方Java类库</li></ul><p>按照技术关注的重点业务划分：</p><ul><li>Java Card</li><li>Java ME（Micro Edition）</li><li>Java SE</li><li>Java EE<h4 id="1-3-Java发展史"><a href="#1-3-Java发展史" class="headerlink" title="1.3 Java发展史"></a>1.3 Java发展史</h4></li></ul><h4 id="1-4-Java虚拟机家族"><a href="#1-4-Java虚拟机家族" class="headerlink" title="1.4 Java虚拟机家族"></a>1.4 Java虚拟机家族</h4><h5 id="1-4-1-虚拟机始祖：Sun-Classic-x2F-Exact-VM"><a href="#1-4-1-虚拟机始祖：Sun-Classic-x2F-Exact-VM" class="headerlink" title="1.4.1 虚拟机始祖：Sun Classic&#x2F;Exact VM"></a>1.4.1 虚拟机始祖：Sun Classic&#x2F;Exact VM</h5><h5 id="1-4-2-武林盟主：HotSpot-VM"><a href="#1-4-2-武林盟主：HotSpot-VM" class="headerlink" title="1.4.2 武林盟主：HotSpot VM"></a>1.4.2 武林盟主：HotSpot VM</h5><h5 id="1-4-3-小家碧玉：Mobile-x2F-Embedded-VM"><a href="#1-4-3-小家碧玉：Mobile-x2F-Embedded-VM" class="headerlink" title="1.4.3 小家碧玉：Mobile&#x2F;Embedded VM"></a>1.4.3 小家碧玉：Mobile&#x2F;Embedded VM</h5><h5 id="1-4-4-天下第二：BEA-JRockit-x2F-IBM-J9-VM"><a href="#1-4-4-天下第二：BEA-JRockit-x2F-IBM-J9-VM" class="headerlink" title="1.4.4 天下第二：BEA JRockit&#x2F;IBM J9 VM"></a>1.4.4 天下第二：BEA JRockit&#x2F;IBM J9 VM</h5><h5 id="1-4-5-软硬合璧：BEA-Liquid-VM-x2F-Azul-VM"><a href="#1-4-5-软硬合璧：BEA-Liquid-VM-x2F-Azul-VM" class="headerlink" title="1.4.5 软硬合璧：BEA Liquid VM&#x2F;Azul VM"></a>1.4.5 软硬合璧：BEA Liquid VM&#x2F;Azul VM</h5><h5 id="1-4-6-挑战者：Apache-Harmony-x2F-Google-Android-Dalvik-VM"><a href="#1-4-6-挑战者：Apache-Harmony-x2F-Google-Android-Dalvik-VM" class="headerlink" title="1.4.6 挑战者：Apache Harmony&#x2F;Google Android Dalvik VM"></a>1.4.6 挑战者：Apache Harmony&#x2F;Google Android Dalvik VM</h5><h5 id="1-4-7-没有成功，但并非失败：Microsoft-JM及其他"><a href="#1-4-7-没有成功，但并非失败：Microsoft-JM及其他" class="headerlink" title="1.4.7 没有成功，但并非失败：Microsoft JM及其他"></a>1.4.7 没有成功，但并非失败：Microsoft JM及其他</h5><h5 id="1-4-8-百家争鸣"><a href="#1-4-8-百家争鸣" class="headerlink" title="1.4.8 百家争鸣"></a>1.4.8 百家争鸣</h5><h4 id="1-5-展望Java技术的未来"><a href="#1-5-展望Java技术的未来" class="headerlink" title="1.5 展望Java技术的未来"></a>1.5 展望Java技术的未来</h4><h5 id="1-5-1-无语言倾向"><a href="#1-5-1-无语言倾向" class="headerlink" title="1.5.1 无语言倾向"></a>1.5.1 无语言倾向</h5><h5 id="1-5-2-新一代即时编译器"><a href="#1-5-2-新一代即时编译器" class="headerlink" title="1.5.2 新一代即时编译器"></a>1.5.2 新一代即时编译器</h5><h5 id="1-5-3-向Native迈进"><a href="#1-5-3-向Native迈进" class="headerlink" title="1.5.3 向Native迈进"></a>1.5.3 向Native迈进</h5><h5 id="1-5-4-灵活的胖子"><a href="#1-5-4-灵活的胖子" class="headerlink" title="1.5.4 灵活的胖子"></a>1.5.4 灵活的胖子</h5><h5 id="1-5-5-语言语法持续增强"><a href="#1-5-5-语言语法持续增强" class="headerlink" title="1.5.5 语言语法持续增强"></a>1.5.5 语言语法持续增强</h5><h4 id="1-6-实战：自己编译JDK"><a href="#1-6-实战：自己编译JDK" class="headerlink" title="1.6 实战：自己编译JDK"></a>1.6 实战：自己编译JDK</h4><h5 id="1-6-1-获取源码"><a href="#1-6-1-获取源码" class="headerlink" title="1.6.1 获取源码"></a>1.6.1 获取源码</h5><h5 id="1-6-2-系统需求"><a href="#1-6-2-系统需求" class="headerlink" title="1.6.2 系统需求"></a>1.6.2 系统需求</h5><h5 id="1-6-3-构建编译环境"><a href="#1-6-3-构建编译环境" class="headerlink" title="1.6.3 构建编译环境"></a>1.6.3 构建编译环境</h5><h5 id="1-6-4-进行编译"><a href="#1-6-4-进行编译" class="headerlink" title="1.6.4 进行编译"></a>1.6.4 进行编译</h5><h5 id="1-6-5-在IDE工具中进行源码调试"><a href="#1-6-5-在IDE工具中进行源码调试" class="headerlink" title="1.6.5 在IDE工具中进行源码调试"></a>1.6.5 在IDE工具中进行源码调试</h5><pre><code>1th Chapter is over.
©qingjiu
</code></pre><h2 id="第二部分-自动内存管理"><a href="#第二部分-自动内存管理" class="headerlink" title="第二部分 自动内存管理"></a>第二部分 自动内存管理</h2><h3 id="2-Java内存区域与内存溢出异常"><a href="#2-Java内存区域与内存溢出异常" class="headerlink" title="2. Java内存区域与内存溢出异常"></a>2. Java内存区域与内存溢出异常</h3><pre><code>2th Chapter is over.
©qingjiu
</code></pre><h3 id="3-垃圾收集器与内存分配策略"><a href="#3-垃圾收集器与内存分配策略" class="headerlink" title="3. 垃圾收集器与内存分配策略"></a>3. 垃圾收集器与内存分配策略</h3><pre><code>3th Chapter is over.
©qingjiu
</code></pre><h3 id="4-虚拟机性能监控、故障处理工具"><a href="#4-虚拟机性能监控、故障处理工具" class="headerlink" title="4. 虚拟机性能监控、故障处理工具"></a>4. 虚拟机性能监控、故障处理工具</h3><pre><code>4th Chapter is over.
©qingjiu
</code></pre><h3 id="5-调优案例分析与实战"><a href="#5-调优案例分析与实战" class="headerlink" title="5. 调优案例分析与实战"></a>5. 调优案例分析与实战</h3><pre><code>5th Chapter is over.
©qingjiu
</code></pre><h2 id="第三部分-虚拟机执行子系统"><a href="#第三部分-虚拟机执行子系统" class="headerlink" title="第三部分 虚拟机执行子系统"></a>第三部分 虚拟机执行子系统</h2><h3 id="6-类文件结构"><a href="#6-类文件结构" class="headerlink" title="6. 类文件结构"></a>6. 类文件结构</h3><pre><code>6th Chapter is over.
©qingjiu
</code></pre><h3 id="7-虚拟机类加载机制"><a href="#7-虚拟机类加载机制" class="headerlink" title="7. 虚拟机类加载机制"></a>7. 虚拟机类加载机制</h3><pre><code>7th Chapter is over.
©qingjiu
</code></pre><h3 id="8-虚拟机字节码执行引擎"><a href="#8-虚拟机字节码执行引擎" class="headerlink" title="8. 虚拟机字节码执行引擎"></a>8. 虚拟机字节码执行引擎</h3><pre><code>8th Chapter is over.
©qingjiu
</code></pre><h3 id="9-类加载及执行子系统的案例与实战"><a href="#9-类加载及执行子系统的案例与实战" class="headerlink" title="9. 类加载及执行子系统的案例与实战"></a>9. 类加载及执行子系统的案例与实战</h3><pre><code>9th Chapter is over.
©qingjiu
</code></pre><h2 id="第四部分-程序编译与代码优化"><a href="#第四部分-程序编译与代码优化" class="headerlink" title="第四部分 程序编译与代码优化"></a>第四部分 程序编译与代码优化</h2><h3 id="10-前端编译与优化"><a href="#10-前端编译与优化" class="headerlink" title="10. 前端编译与优化"></a>10. 前端编译与优化</h3><pre><code>10th Chapter is over.
©qingjiu
</code></pre><h3 id="11-后端编译与优化"><a href="#11-后端编译与优化" class="headerlink" title="11. 后端编译与优化"></a>11. 后端编译与优化</h3><pre><code>11th Chapter is over.
©qingjiu
</code></pre><h2 id="第五部分-高效并发"><a href="#第五部分-高效并发" class="headerlink" title="第五部分 高效并发"></a>第五部分 高效并发</h2><h3 id="12-Java内存模型与线程"><a href="#12-Java内存模型与线程" class="headerlink" title="12. Java内存模型与线程"></a>12. Java内存模型与线程</h3><pre><code>12th Chapter is over.
©qingjiu
</code></pre><h3 id="13-线程安全与锁优化"><a href="#13-线程安全与锁优化" class="headerlink" title="13. 线程安全与锁优化"></a>13. 线程安全与锁优化</h3><pre><code>13th Chapter is over.
©qingjiu
</code></pre></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-10 11:31:43" itemprop="dateModified" datetime="2022-03-10T11:31:43+08:00">2022-03-10</time></span></div></header><div class="post-body" itemprop="articleBody"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">极客时间 《设计模式之美》——王争</span><br><span class="line"><span class="deletion">-学习笔记</span></span><br></pre></td></tr></table></figure><h1 id="设计模式学习导读"><a href="#设计模式学习导读" class="headerlink" title="设计模式学习导读"></a>设计模式学习导读</h1><h2 id="为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？"><a href="#为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？" class="headerlink" title="为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？"></a>为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/160981">文章链接</a></p><h2 id="从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？"><a href="#从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？" class="headerlink" title="从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？"></a>从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？</h2><h3 id="1-如何评价代码质量的高低？"><a href="#1-如何评价代码质量的高低？" class="headerlink" title="1. 如何评价代码质量的高低？"></a>1. 如何评价代码质量的高低？</h3><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。</p><h3 id="2-最常用的评价标准有哪几个？"><a href="#2-最常用的评价标准有哪几个？" class="headerlink" title="2. 最常用的评价标准有哪几个？"></a>2. 最常用的评价标准有哪几个？</h3><p>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><h3 id="3-如何才能写出高质量的代码？"><a href="#3-如何才能写出高质量的代码？" class="headerlink" title="3. 如何才能写出高质量的代码？"></a>3. 如何才能写出高质量的代码？</h3><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等，这也是我们后面课程学习的重点。</p><h2 id="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a>面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</h2><p><img src="https://gitee.com/green-wine/myProjects/raw/master/MyDocs/image/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81.png"></p><h1 id="设计原则与思想：面向对象"><a href="#设计原则与思想：面向对象" class="headerlink" title="设计原则与思想：面向对象"></a>设计原则与思想：面向对象</h1><h2 id="理论一：当谈论面向对象的时候，我们到底在谈论什么？"><a href="#理论一：当谈论面向对象的时候，我们到底在谈论什么？" class="headerlink" title="理论一：当谈论面向对象的时候，我们到底在谈论什么？"></a>理论一：当谈论面向对象的时候，我们到底在谈论什么？</h2><h3 id="1-什么是面向对象编程？"><a href="#1-什么是面向对象编程？" class="headerlink" title="1. 什么是面向对象编程？"></a>1. 什么是面向对象编程？</h3><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p><h3 id="2-什么是面向对象编程语言？"><a href="#2-什么是面向对象编程语言？" class="headerlink" title="2. 什么是面向对象编程语言？"></a>2. 什么是面向对象编程语言？</h3><p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p><h3 id="3-如何判定一个编程语言是否是面向对象编程语言？"><a href="#3-如何判定一个编程语言是否是面向对象编程语言？" class="headerlink" title="3. 如何判定一个编程语言是否是面向对象编程语言？"></a>3. 如何判定一个编程语言是否是面向对象编程语言？</h3><p>如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。</p><h3 id="4-面向对象编程和面向对象编程语言之间有何关系？"><a href="#4-面向对象编程和面向对象编程语言之间有何关系？" class="headerlink" title="4. 面向对象编程和面向对象编程语言之间有何关系？"></a>4. 面向对象编程和面向对象编程语言之间有何关系？</h3><p>面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p><h3 id="5-什么是面向对象分析和面向对象设计？"><a href="#5-什么是面向对象分析和面向对象设计？" class="headerlink" title="5. 什么是面向对象分析和面向对象设计？"></a>5. 什么是面向对象分析和面向对象设计？</h3><p>简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。</p><h2 id="理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"><a href="#理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？" class="headerlink" title="理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"></a>理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？</h2><h3 id="1-关于封装特性"><a href="#1-关于封装特性" class="headerlink" title="1. 关于封装特性"></a>1. 关于封装特性</h3><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><h3 id="2-关于抽象特性"><a href="#2-关于抽象特性" class="headerlink" title="2. 关于抽象特性"></a>2. 关于抽象特性</h3><p>封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><h3 id="3-关于继承特性"><a href="#3-关于继承特性" class="headerlink" title="3. 关于继承特性"></a>3. 关于继承特性</h3><p>继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><h3 id="4-关于多态特性"><a href="#4-关于多态特性" class="headerlink" title="4. 关于多态特性"></a>4. 关于多态特性</h3><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h2 id="理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"><a href="#理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？" class="headerlink" title="理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"></a>理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？</h2><h3 id="1-什么是面向过程编程？什么是面向过程编程语言？"><a href="#1-什么是面向过程编程？什么是面向过程编程语言？" class="headerlink" title="1. 什么是面向过程编程？什么是面向过程编程语言？"></a>1. 什么是面向过程编程？什么是面向过程编程语言？</h3><p>实际上，面向过程编程和面向过程编程语言并没有严格的官方定义。理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。</p><h3 id="2-面向对象编程相比面向过程编程有哪些优势？"><a href="#2-面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="2. 面向对象编程相比面向过程编程有哪些优势？"></a>2. 面向对象编程相比面向过程编程有哪些优势？</h3><p>面向对象编程相比起面向过程编程的优势主要有三个。对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</p><h2 id="理论四：哪些代码设计看似是面向对象，实际是面向过程的？"><a href="#理论四：哪些代码设计看似是面向对象，实际是面向过程的？" class="headerlink" title="理论四：哪些代码设计看似是面向对象，实际是面向过程的？"></a>理论四：哪些代码设计看似是面向对象，实际是面向过程的？</h2><h3 id="1-滥用-getter、setter-方法"><a href="#1-滥用-getter、setter-方法" class="headerlink" title="1. 滥用 getter、setter 方法"></a>1. 滥用 getter、setter 方法</h3><p>在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。</p><h3 id="2-Constants-类、Utils-类的设计问题"><a href="#2-Constants-类、Utils-类的设计问题" class="headerlink" title="2.Constants 类、Utils 类的设计问题"></a>2.Constants 类、Utils 类的设计问题</h3><p>对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。</p><h3 id="3-基于贫血模型的开发模式"><a href="#3-基于贫血模型的开发模式" class="headerlink" title="3. 基于贫血模型的开发模式"></a>3. 基于贫血模型的开发模式</h3><p>关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO&#x2F;BO&#x2F;Entity 和 Controller&#x2F;Service&#x2F;Repository 中的。今天，你只需要掌握这一点就可以了。为什么这种开发模式如此流行？如何规避面向过程编程的弊端？有没有更好的可替代的开发模式？相关的更多问题，我们在面向对象实战篇中会一一讲解。</p><h2 id="理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？"><a href="#理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？" class="headerlink" title="理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？"></a>理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？</h2><h3 id="1-抽象类和接口的语法特性"><a href="#1-抽象类和接口的语法特性" class="headerlink" title="1. 抽象类和接口的语法特性"></a>1. 抽象类和接口的语法特性</h3><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><h3 id="2-抽象类和接口存在的意义"><a href="#2-抽象类和接口存在的意义" class="headerlink" title="2. 抽象类和接口存在的意义"></a>2. 抽象类和接口存在的意义</h3><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><h3 id="3-抽象类和接口的应用场景区别"><a href="#3-抽象类和接口的应用场景区别" class="headerlink" title="3. 抽象类和接口的应用场景区别"></a>3. 抽象类和接口的应用场景区别</h3><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h2 id="理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h2><ol><li>“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</li><li>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</li><li>“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</li></ol><h2 id="理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？"><a href="#理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？" class="headerlink" title="理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？"></a>理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？</h2><h3 id="1-为什么不推荐使用继承？"><a href="#1-为什么不推荐使用继承？" class="headerlink" title="1. 为什么不推荐使用继承？"></a>1. 为什么不推荐使用继承？</h3><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p><h3 id="2-组合相比继承有哪些优势？"><a href="#2-组合相比继承有哪些优势？" class="headerlink" title="2. 组合相比继承有哪些优势？"></a>2. 组合相比继承有哪些优势？</h3><p>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><h3 id="3-如何判断该用组合还是继承？"><a href="#3-如何判断该用组合还是继承？" class="headerlink" title="3. 如何判断该用组合还是继承？"></a>3. 如何判断该用组合还是继承？</h3><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h2 id="实战一"><a href="#实战一" class="headerlink" title="实战一"></a>实战一</h2><h3 id="业务开发常用的基于贫血模型的MVC架构违背OOP吗？"><a href="#业务开发常用的基于贫血模型的MVC架构违背OOP吗？" class="headerlink" title="业务开发常用的基于贫血模型的MVC架构违背OOP吗？"></a>业务开发常用的基于贫血模型的MVC架构违背OOP吗？</h3><p>我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构，在专栏中它被称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的 DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p><p>不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><h3 id="如何利用基于充血模型的DDD开发一个虚拟钱包系统？"><a href="#如何利用基于充血模型的DDD开发一个虚拟钱包系统？" class="headerlink" title="如何利用基于充血模型的DDD开发一个虚拟钱包系统？"></a>如何利用基于充血模型的DDD开发一个虚拟钱包系统？</h3><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。</p><p>在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><h2 id="实战二"><a href="#实战二" class="headerlink" title="实战二"></a>实战二</h2><h3 id="如何对接口鉴权这样一个功能开发做面向对象分析？"><a href="#如何对接口鉴权这样一个功能开发做面向对象分析？" class="headerlink" title="如何对接口鉴权这样一个功能开发做面向对象分析？"></a>如何对接口鉴权这样一个功能开发做面向对象分析？</h3><p>针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。</p><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p><h3 id="如何利用面向对象设计和编程开发接口鉴权功能？"><a href="#如何利用面向对象设计和编程开发接口鉴权功能？" class="headerlink" title="如何利用面向对象设计和编程开发接口鉴权功能？"></a>如何利用面向对象设计和编程开发接口鉴权功能？</h3><h4 id="1-划分职责进而识别出有哪些类"><a href="#1-划分职责进而识别出有哪些类" class="headerlink" title="1. 划分职责进而识别出有哪些类"></a>1. 划分职责进而识别出有哪些类</h4><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p><h4 id="2-定义类及其属性和方法"><a href="#2-定义类及其属性和方法" class="headerlink" title="2. 定义类及其属性和方法"></a>2. 定义类及其属性和方法</h4><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p><h4 id="3-定义类与类之间的交互关系"><a href="#3-定义类与类之间的交互关系" class="headerlink" title="3. 定义类与类之间的交互关系"></a>3. 定义类与类之间的交互关系</h4><p>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。</p><h4 id="4-将类组装起来并提供执行入口"><a href="#4-将类组装起来并提供执行入口" class="headerlink" title="4. 将类组装起来并提供执行入口"></a>4. 将类组装起来并提供执行入口</h4><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p><p>软件设计的自由度很大，这也是软件的复杂之处。不同的人对类的划分、定义、类之间交互的设计，可能都不大一样。</p><h1 id="设计原则与思想：设计原则"><a href="#设计原则与思想：设计原则" class="headerlink" title="设计原则与思想：设计原则"></a>设计原则与思想：设计原则</h1><h2 id="理论一：单一职责原则——对于单一职责原则，如何判定某个类的职责是否够“单一”？"><a href="#理论一：单一职责原则——对于单一职责原则，如何判定某个类的职责是否够“单一”？" class="headerlink" title="理论一：单一职责原则——对于单一职责原则，如何判定某个类的职责是否够“单一”？"></a>理论一：单一职责原则——对于单一职责原则，如何判定某个类的职责是否够“单一”？</h2><h3 id="1-如何理解单一职责原则（SRP）？"><a href="#1-如何理解单一职责原则（SRP）？" class="headerlink" title="1. 如何理解单一职责原则（SRP）？"></a>1. 如何理解单一职责原则（SRP）？</h3><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><h3 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2. 如何判断类的职责是否足够单一？"></a>2. 如何判断类的职责是否足够单一？</h3><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：类中的代码行数、函数或者属性过多；类依赖的其他类过多，或者依赖类的其他类过多；私有方法过多；比较难给类起一个合适的名字；类中大量的方法都是集中操作类中的某几个属性。</p><h3 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3. 类的职责是否设计得越单一越好？"></a>3. 类的职责是否设计得越单一越好？</h3><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><h2 id="理论二：开闭原则——如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#理论二：开闭原则——如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="理论二：开闭原则——如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>理论二：开闭原则——如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h2><h3 id="1-如何理解“对扩展开放、对修改关闭”？"><a href="#1-如何理解“对扩展开放、对修改关闭”？" class="headerlink" title="1. 如何理解“对扩展开放、对修改关闭”？"></a>1. 如何理解“对扩展开放、对修改关闭”？</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><h3 id="2-如何做到“对扩展开放、修改关闭”？"><a href="#2-如何做到“对扩展开放、修改关闭”？" class="headerlink" title="2. 如何做到“对扩展开放、修改关闭”？"></a>2. 如何做到“对扩展开放、修改关闭”？</h3><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h2 id="理论三：里氏替换原则——里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#理论三：里氏替换原则——里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="理论三：里氏替换原则——里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>理论三：里氏替换原则——里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h2><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h2 id="理论四：接口隔离原则——接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#理论四：接口隔离原则——接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="理论四：接口隔离原则——接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>理论四：接口隔离原则——接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h2><h3 id="1-如何理解“接口隔离原则”？"><a href="#1-如何理解“接口隔离原则”？" class="headerlink" title="1. 如何理解“接口隔离原则”？"></a>1. 如何理解“接口隔离原则”？</h3><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><h3 id="2-接口隔离原则与单一职责原则的区别"><a href="#2-接口隔离原则与单一职责原则的区别" class="headerlink" title="2. 接口隔离原则与单一职责原则的区别"></a>2. 接口隔离原则与单一职责原则的区别</h3><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h2 id="理论五：依赖翻转原则——控制反转、依赖反转、依赖注入，这三者有何区别和联系？"><a href="#理论五：依赖翻转原则——控制反转、依赖反转、依赖注入，这三者有何区别和联系？" class="headerlink" title="理论五：依赖翻转原则——控制反转、依赖反转、依赖注入，这三者有何区别和联系？"></a>理论五：依赖翻转原则——控制反转、依赖反转、依赖注入，这三者有何区别和联系？</h2><h3 id="1-控制反转"><a href="#1-控制反转" class="headerlink" title="1. 控制反转"></a>1. 控制反转</h3><p>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h3><p>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p><h3 id="3-依赖注入框架"><a href="#3-依赖注入框架" class="headerlink" title="3. 依赖注入框架"></a>3. 依赖注入框架</h3><p>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><h3 id="4-依赖反转原则"><a href="#4-依赖反转原则" class="headerlink" title="4. 依赖反转原则"></a>4. 依赖反转原则</h3><p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</p><h2 id="理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"><a href="#理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？" class="headerlink" title="理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"></a>理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？</h2><p>KISS 原则是保持代码可读和可维护的重要手段。KISS 原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p><p>对于如何写出满足 KISS 原则的代码，我还总结了下面几条指导原则：</p><ul><li><p>不要使用同事可能不懂的技术来实现代码；</p></li><li><p>不要重复造轮子，要善于使用已经有的工具类库；</p></li><li><p>不要过度优化。</p></li></ul><p>KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h2 id="理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</h2><p>提高代码可复用性的一些方法，有以下 7 点。</p><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><p>实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。</p><p>我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>相比于代码的可复用性，DRY 原则适用性更强一些。我们可以不写可复用的代码，但一定不能写重复的代码。</p><h2 id="理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"><a href="#理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？" class="headerlink" title="理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"></a>理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？</h2><h3 id="1-如何理解“高内聚、松耦合”？"><a href="#1-如何理解“高内聚、松耦合”？" class="headerlink" title="1. 如何理解“高内聚、松耦合”？"></a>1. 如何理解“高内聚、松耦合”？</h3><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><h3 id="2-如何理解“迪米特法则”？"><a href="#2-如何理解“迪米特法则”？" class="headerlink" title="2. 如何理解“迪米特法则”？"></a>2. 如何理解“迪米特法则”？</h3><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><h1 id="设计模式与范式：创建型"><a href="#设计模式与范式：创建型" class="headerlink" title="设计模式与范式：创建型"></a>设计模式与范式：创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="为什么说支持懒加载的双重检测不比饿汉式更优？"><a href="#为什么说支持懒加载的双重检测不比饿汉式更优？" class="headerlink" title="为什么说支持懒加载的双重检测不比饿汉式更优？"></a>为什么说支持懒加载的双重检测不比饿汉式更优？</h3><h4 id="1-单例的定义"><a href="#1-单例的定义" class="headerlink" title="1. 单例的定义"></a>1. 单例的定义</h4><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><h4 id="2-单例的用处"><a href="#2-单例的用处" class="headerlink" title="2. 单例的用处"></a>2. 单例的用处</h4><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</p><h4 id="3-单例的实现"><a href="#3-单例的实现" class="headerlink" title="3. 单例的实现"></a>3. 单例的实现</h4><p>单例有下面几种经典的实现方式。</p><ul><li>饿汉式</li></ul><p>饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p><ul><li>懒汉式</li></ul><p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</p><ul><li>双重检测</li></ul><p>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p><ul><li>静态内部类</li></ul><p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p><ul><li>枚举</li></ul><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><h3 id="为什么不推荐使用单例模式？又有何替代方案？"><a href="#为什么不推荐使用单例模式？又有何替代方案？" class="headerlink" title="为什么不推荐使用单例模式？又有何替代方案？"></a>为什么不推荐使用单例模式？又有何替代方案？</h3><h4 id="1-单例存在哪些问题？"><a href="#1-单例存在哪些问题？" class="headerlink" title="1. 单例存在哪些问题？"></a>1. 单例存在哪些问题？</h4><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><h4 id="2-单例有什么替代解决方案？"><a href="#2-单例有什么替代解决方案？" class="headerlink" title="2. 单例有什么替代解决方案？"></a>2. 单例有什么替代解决方案？</h4><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><h3 id="如何设计实现一个集群环境下的分布式单例模式？"><a href="#如何设计实现一个集群环境下的分布式单例模式？" class="headerlink" title="如何设计实现一个集群环境下的分布式单例模式？"></a>如何设计实现一个集群环境下的分布式单例模式？</h3><h4 id="1-如何理解单例模式的唯一性？"><a href="#1-如何理解单例模式的唯一性？" class="headerlink" title="1. 如何理解单例模式的唯一性？"></a>1. 如何理解单例模式的唯一性？</h4><p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p><h4 id="2-如何实现线程唯一的单例？"><a href="#2-如何实现线程唯一的单例？" class="headerlink" title="2. 如何实现线程唯一的单例？"></a>2. 如何实现线程唯一的单例？</h4><p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。</p><h4 id="3-如何实现集群环境下的单例？"><a href="#3-如何实现集群环境下的单例？" class="headerlink" title="3. 如何实现集群环境下的单例？"></a>3. 如何实现集群环境下的单例？</h4><p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><h4 id="4-如何实现一个多例模式？"><a href="#4-如何实现一个多例模式？" class="headerlink" title="4. 如何实现一个多例模式？"></a>4. 如何实现一个多例模式？</h4><p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="为什么说没事不要随便用工厂模式创建对象？"><a href="#为什么说没事不要随便用工厂模式创建对象？" class="headerlink" title="为什么说没事不要随便用工厂模式创建对象？"></a>为什么说没事不要随便用工厂模式创建对象？</h3><p>在今天讲的三种工厂模式中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。所以，下面我重点对前两种工厂模式的应用场景进行总结。</p><p>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。何为创建逻辑比较复杂呢？我总结了下面两种情况。</p><ul><li><p>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。</p></li><li><p>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p></li></ul><p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p><p>除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。</p><p>现在，我们上升一个思维层面来看工厂模式，它的作用无外乎下面这四个。这也是判断要不要使用工厂模式的最本质的参考标准。</p><ul><li><p>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</p></li><li><p>代码复用：创建代码抽离到独立的工厂类之后可以复用。</p></li><li><p>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</p></li><li><p>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</p></li></ul><h3 id="如何设计实现一个Dependency-Injection框架？"><a href="#如何设计实现一个Dependency-Injection框架？" class="headerlink" title="如何设计实现一个Dependency Injection框架？"></a>如何设计实现一个Dependency Injection框架？</h3><p>DI 容器在一些软件开发中已经成为了标配，比如 Spring IOC、Google Guice。但是，大部分人可能只是把它当作一个黑盒子来使用，并未真正去了解它的底层是如何实现的。当然，如果只是做一些简单的小项目，简单会用就足够了，但是，如果我们面对的是非常复杂的系统，当系统出现问题的时候，对底层原理的掌握程度，决定了我们排查问题的能力，直接影响到我们排查问题的效率。</p><p>今天，我们讲解了一个简单的 DI 容器的实现原理，其核心逻辑主要包括：配置文件解析，以及根据配置文件通过“反射”语法来创建对象。其中，创建对象的过程就应用到了我们在学的工厂模式。对象创建、组装、管理完全有 DI 容器来负责，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="详解构造函数、set方法、建造者模式三种对象创建方式"><a href="#详解构造函数、set方法、建造者模式三种对象创建方式" class="headerlink" title="详解构造函数、set方法、建造者模式三种对象创建方式"></a>详解构造函数、set方法、建造者模式三种对象创建方式</h3><p>建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li><p>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</p></li><li><p>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</p></li><li><p>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</p></li></ul><p>除此之外，关于工厂模式和建造者模式的区别。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p><h2 id="原型模式：如何最快速地clone一个HashMap散列表？"><a href="#原型模式：如何最快速地clone一个HashMap散列表？" class="headerlink" title="原型模式：如何最快速地clone一个HashMap散列表？"></a>原型模式：如何最快速地clone一个HashMap散列表？</h2><h3 id="1-什么是原型模式？"><a href="#1-什么是原型模式？" class="headerlink" title="1. 什么是原型模式？"></a>1. 什么是原型模式？</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><h3 id="2-原型模式的两种实现方法"><a href="#2-原型模式的两种实现方法" class="headerlink" title="2. 原型模式的两种实现方法"></a>2. 原型模式的两种实现方法</h3><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。除非像我们今天实战中举的那个例子，需要从数据库中加载 10 万条数据并构建散列表索引，操作非常耗时，这种情况下比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h1 id="设计模式与范式：结构型"><a href="#设计模式与范式：结构型" class="headerlink" title="设计模式与范式：结构型"></a>设计模式与范式：结构型</h1><h2 id="代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="代理模式：代理在RPC、缓存、监控等场景中的应用"></a>代理模式：代理在RPC、缓存、监控等场景中的应用</h2></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-10 11:31:43" itemprop="dateModified" datetime="2022-03-10T11:31:43+08:00">2022-03-10</time></span></div></header><div class="post-body" itemprop="articleBody"><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考书籍：</span><br><span class="line">Software Engineering : <span class="type">A</span> PRACTIONER<span class="symbol">&#x27;S</span> APPROACH(Pressman)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/%E9%9B%B6%E6%95%A3%E4%B8%9A%E5%8A%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/%E9%9B%B6%E6%95%A3%E4%B8%9A%E5%8A%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-12-15 10:48:44" itemprop="dateModified" datetime="2021-12-15T10:48:44+08:00">2021-12-15</time></span></div></header><div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="http://apframework.com/2019/12/07/ddd-business-architecture/">DDD:Business Architecture（领域驱动设计系列）</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/%E9%9B%B6%E6%95%A3%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/%E9%9B%B6%E6%95%A3%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-10 11:31:43" itemprop="dateModified" datetime="2022-03-10T11:31:43+08:00">2022-03-10</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><p>普通字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ABC]	<span class="comment">//匹配[...]中的所有字符</span></span><br><span class="line">[^ABC]	<span class="comment">//匹配除了[...]中的所有字符</span></span><br><span class="line">[A-Z]	<span class="comment">//[A-Z]表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</span></span><br><span class="line">.		<span class="comment">//匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。</span></span><br><span class="line">[\s\S]	<span class="comment">//匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</span></span><br><span class="line">\w		<span class="comment">//匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非打印字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\cx		<span class="comment">//匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &#x27;c&#x27; 字符。</span></span><br><span class="line">\f		<span class="comment">//匹配一个换页符。等价于 \x0c 和 \cL。</span></span><br><span class="line">\n		<span class="comment">//匹配一个换行符。等价于 \x0a 和 \cJ。</span></span><br><span class="line">\r		<span class="comment">//匹配一个回车符。等价于 \x0d 和 \cM。</span></span><br><span class="line">\s		<span class="comment">//匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</span></span><br><span class="line">\S		<span class="comment">//匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</span></span><br><span class="line">\t		<span class="comment">//匹配一个制表符。等价于 \x09 和 \cI。</span></span><br><span class="line">\v		<span class="comment">//匹配一个垂直制表符。等价于 \x0b 和 \cK。</span></span><br></pre></td></tr></table></figure><p>特殊字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$		<span class="comment">//匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 &#x27;\n&#x27; 或 &#x27;\r&#x27;。要匹配 $ 字符本身，请使用 \$。</span></span><br><span class="line">( )		<span class="comment">//标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。</span></span><br><span class="line">*		<span class="comment">//匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。</span></span><br><span class="line">+		<span class="comment">//匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。</span></span><br><span class="line">.		<span class="comment">//匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。</span></span><br><span class="line">[		<span class="comment">//标记一个中括号表达式的开始。要匹配 [，请使用 \[。</span></span><br><span class="line">?		<span class="comment">//匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</span></span><br><span class="line">\		<span class="comment">//将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， &#x27;n&#x27; 匹配字符 &#x27;n&#x27;。&#x27;\n&#x27; 匹配换行符。序列 &#x27;\\&#x27; 匹配 &quot;\&quot;，而 &#x27;\(&#x27; 则匹配 &quot;(&quot;。</span></span><br><span class="line">^		<span class="comment">//匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。</span></span><br><span class="line">&#123;		<span class="comment">//标记限定符表达式的开始。要匹配 &#123;，请使用 \&#123;。</span></span><br><span class="line">|		<span class="comment">//指明两项之间的一个选择。要匹配 |，请使用 \|。</span></span><br><span class="line">\b		<span class="comment">//匹配一个单词边界，即字与空格间的位置。</span></span><br><span class="line">\B		<span class="comment">//非单词边界匹配。</span></span><br></pre></td></tr></table></figure><p>限定符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*		<span class="comment">//匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于&#123;0,&#125;。</span></span><br><span class="line">+		<span class="comment">//匹配前面的子表达式一次或多次。例如，&#x27;zo+&#x27; 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 &#123;1,&#125;。</span></span><br><span class="line">?		<span class="comment">//匹配前面的子表达式零次或一次。例如，&quot;do(es)?&quot; 可以匹配 &quot;do&quot; 、 &quot;does&quot; 中的 &quot;does&quot; 、 &quot;doxy&quot; 中的 &quot;do&quot; 。? 等价于 &#123;0,1&#125;。</span></span><br><span class="line">&#123;n&#125;		<span class="comment">//n 是一个非负整数。匹配确定的 n 次。例如，&#x27;o&#123;2&#125;&#x27; 不能匹配 &quot;Bob&quot; 中的 &#x27;o&#x27;，但是能匹配 &quot;food&quot; 中的两个 o。</span></span><br><span class="line">&#123;n,&#125;	<span class="comment">//n 是一个非负整数。至少匹配n 次。例如，&#x27;o&#123;2,&#125;&#x27; 不能匹配 &quot;Bob&quot; 中的 &#x27;o&#x27;，但能匹配 &quot;foooood&quot; 中的所有 o。&#x27;o&#123;1,&#125;&#x27; 等价于 &#x27;o+&#x27;。&#x27;o&#123;0,&#125;&#x27; 则等价于 &#x27;o*&#x27;。</span></span><br><span class="line">&#123;n,m&#125;	<span class="comment">//m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，&quot;o&#123;1,3&#125;&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。&#x27;o&#123;0,1&#125;&#x27; 等价于 &#x27;o?&#x27;。请注意在逗号和两个数之间不能有空格。</span></span><br></pre></td></tr></table></figure><hr><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>&amp;emsp;&amp;emsp;用于版本控制（Version Control System ）Git是分布式存储系统，GitHub和BitBucket都是Git的托管平台。</p><p>&amp;emsp;&amp;emsp;以GitHub Desktop为例，GitHub Desktop是GitHub团队开发的可视化管理工具，可以以HTTP的方式通过账号密码连接GitHub或者SSH方式【未解决】，也可以连接BitBucket平台。</p><p>&amp;emsp;&amp;emsp;整体架构可以分为云端（origin）和客户端（local）。初始时，客户端可以在本地创建新的仓库或者从云端Clone下来账号里已经存在的仓库。当在本地对项目做了更改，可以Commit到本地数据库，再Push到云端。本地端可以使用Pull将云端项目拉到本地。需要注意的是，本地更改后，如果Pull将会造成版本冲突的问题，就需要先Stash项目放到暂存箱，再拉下来云端版本，所以需要养成经常Pull的习惯。</p><h4 id="1-ignore文件"><a href="#1-ignore文件" class="headerlink" title="1. ignore文件"></a>1. ignore文件</h4><h5 id="为什么要有-gitignore文件"><a href="#为什么要有-gitignore文件" class="headerlink" title="为什么要有.gitignore文件"></a>为什么要有.gitignore文件</h5><p>&amp;emsp;&amp;emsp;项目中经常会生成一些Git系统不需要追踪(track)的文件。典型的是在编译生成过程中产生的文件或是编程器生成的临时备份文件。当然，你不追踪(track)这些文件，可以平时不用”git add”去把它们加到索引中。 但是这样会很快变成一件烦人的事，你发现项目中到处有未追踪(untracked)的文件; 这样也使”git add .” 和”gi commit -a” 变得实际上没有用处，同时”git status”命令的输出也会有它们。你可以在你的顶层工作目录中添加一个叫”.gitignore”的文件，来告诉Git系统要忽略 掉哪些文件。</p><h5 id="忽略文件原则"><a href="#忽略文件原则" class="headerlink" title="忽略文件原则"></a>忽略文件原则</h5><p>&amp;emsp;&amp;emsp;忽略操作系统自动生成的文件，比如缩略图等；<br>&amp;emsp;&amp;emsp;忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>&amp;emsp;&amp;emsp;忽略你自己的带有敏感信息的配置文件，比如存放指令的配置文件。</p><h5 id="语法规范（熟悉正则很容易理解）"><a href="#语法规范（熟悉正则很容易理解）" class="headerlink" title="语法规范（熟悉正则很容易理解）"></a>语法规范（熟悉正则很容易理解）</h5><p>空格或是以#开头的行即注释的将被忽略；</p><pre><code>以斜杠 “/” 结尾表示目录；    
以星号 “*” 通配多个字符；    
以问号 “?” 通配单个字符；    
以方括号 “[]” 包含单个字符的匹配列表；    
以叹号 “!” 表示不忽略(跟踪)匹配到的文件或目录；    
可以在前面添加斜杠 “/” 来避免递归,下列的例子中可以很明显的看出来与下一条的区别。    
</code></pre><p>配置文件示例</p><blockquote><p><strong>忽略 .a 文件</strong><br><em>.a<br><strong>但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件</strong><br>!lib.a<br><strong>仅在当前文录下忽略 TODO 文件， 但不包括子目录下的 subdir&#x2F;TODO</strong><br>&#x2F;TODO<br><strong>忽略 build&#x2F; 文件夹下的所有文件</strong><br>build&#x2F;<br><strong>忽略 doc&#x2F;notes.txt, 不包括 doc&#x2F;server&#x2F;arch.txt</strong><br>doc&#x2F;</em>.txt<br><strong>忽略在 doc&#x2F; 及其各子目录下的所有的 .pdf 文件</strong><br>doc&#x2F;**&#x2F;*.pdf</p></blockquote><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git commit -m &#x27;xxx&#x27;                                       # 提交 </span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line"></span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git merge origin/master                                   # 合并远程master分支至当前分支</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &#x27;xxx&#x27;                                       # 提交</span><br><span class="line">git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features/performance                         # 检出已存在的features/performance分支</span><br><span class="line">git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin/master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git remote												  # 查看当前本地仓库关联了哪些远程仓库</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure><h4 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h4><h5 id="Git创建本地仓库并同步到远程"><a href="#Git创建本地仓库并同步到远程" class="headerlink" title="Git创建本地仓库并同步到远程"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35161540/article/details/74626000">Git创建本地仓库并同步到远程</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 地址							    #给本地仓库添加远端服务器，并起别名为origin</span><br></pre></td></tr></table></figure><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>&amp;emsp;&amp;emsp;可以使我们在编译时检查出错误，而不是运行时。<br>&amp;emsp;&amp;emsp;泛型将类型参数化，据此特性可以定义带泛型类型的类和方法。</p><hr><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><pre><code>Spring之前使用EJB。
EJB (Enterprise Java Beans) 是基于分布式事务处理的企业级应用程序的组件。
EJB是用于开发和部署多层结构的、分布式的、面向对象的Java应用系统的跨平台的构件体系结构。
</code></pre><p>&amp;emsp;&amp;emsp;在实际开发中，服务器端通常采用三层体系架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。</p><p>&amp;emsp;&amp;emsp;Spring 致力于 Java EE 应用各层的解决方案，对每一层都提供了技术支持。在表现层提供了与 Spring MVC、Struts2 框架的整合，在业务逻辑层可以管理事务和记录日志等，在持久层可以整合 MyBatis、Hibernate 和 JdbcTemplate 等技术。这就充分体现出 Spring 是一个全面的解决方案，对于已经有较好解决方案的领域，Spring 绝不做重复的事情。</p><p>&amp;emsp;&amp;emsp;从某个程度上来看，Spring 框架充当了黏合剂和润滑剂的角色，能够将相应的 Java Web 系统柔顺地整合起来，并让它们更易使用。同时其本身还提供了声明式事务等企业级开发不可或缺的功能。</p><hr><h3 id="SOFA"><a href="#SOFA" class="headerlink" title="SOFA"></a>SOFA</h3><p>&amp;emsp;&amp;emsp;SOFA 是蚂蚁金服自主研发的金融级分布式中间件，包含了构建金融级云原生架构所需的各个组件，包括微服务研发框架，RPC 框架，服务注册中心，分布式定时任务，限流&#x2F;熔断框架，动态配置推送，分布式链路追踪，Metrics监控度量，分布式高可用消息队列，分布式事务框架，分布式数据库代理层等组件，是一套分布式架构的完整的解决方案，也是在金融场景里锤炼出来的最佳实践。</p><p>&amp;emsp;&amp;emsp;链接：<br>&amp;emsp;&amp;emsp;<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e3dca8d5e9ee">再探蚂蚁中间件：SOFA</a><br>&amp;emsp;&amp;emsp;<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab3acb2bb518">SOFA源码学习</a></p><hr><h3 id="SOFABoot"><a href="#SOFABoot" class="headerlink" title="SOFABoot"></a>SOFABoot</h3><p>SOFABoot 是蚂蚁集团开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，上下文隔离，类隔离，日志空间隔离等等能力。在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFA 中间件的能力。<br><a target="_blank" rel="noopener" href="https://github.com/sofastack/sofa-boot">GitHub:sofa-boot</a></p><hr><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><h4 id="父工程的用处"><a href="#父工程的用处" class="headerlink" title="父工程的用处"></a>父工程的用处</h4><p>1、统一管理jar包的版本，其依赖需要在子工程中定义才有效<br>2、统一的依赖管理<br>3、控制插件的版本<br>4、聚合工程</p><h4 id="Maven中的依赖"><a href="#Maven中的依赖" class="headerlink" title="Maven中的依赖"></a>Maven中的依赖</h4><p>&amp;emsp;&amp;emsp;dependency相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。<br>&amp;emsp;&amp;emsp;dependencies即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承）<br>&amp;emsp;&amp;emsp;dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p><h4 id="Maven中的聚合"><a href="#Maven中的聚合" class="headerlink" title="Maven中的聚合"></a>Maven中的聚合</h4><p>&amp;emsp;&amp;emsp;父工程可以做为聚合工程（使用module标签）（一般也是这样），但并非一定要在父工程里面做聚合，聚合与继承是两个不相干的概念，可以另外建一个工程做聚合。<br>&amp;emsp;&amp;emsp;Maven 的聚合其实就是项目与子项目的表示，其存在的意义在于快速构建项目。例如我们有一个淘宝商城项目，这个项目有账号子项目和邮件子项目。在这个时候我们需要在 Maven 中表达这种项目归属关系，那么我们就可以用 Maven 的聚合来进行配置。</p><h4 id="Maven中的继承"><a href="#Maven中的继承" class="headerlink" title="Maven中的继承"></a>Maven中的继承</h4><p>&amp;emsp;&amp;emsp;在Maven中，子项目是可以继承父项目中的依赖的，比如说我们有一个父项目maven-parent，该父项目拥有一个子项目A，如果在父项目中依赖了junit，那么在子项目A中即便是没有引入junit，在子项目中仍然能够使用junit，因为子项目天然继承了父项目中的junit依赖。</p><h4 id="聚合和继承的关系"><a href="#聚合和继承的关系" class="headerlink" title="聚合和继承的关系"></a>聚合和继承的关系</h4><p>&amp;emsp;&amp;emsp;从上面可以看到多模块 Maven 项目中的聚合与继承其实是两个概念，其目的是完全不同的。聚合是为了方便快速构建项目，继承是为了消除重复配置。<br>&amp;emsp;&amp;emsp;对于聚合模块来说，它知道哪些被聚合的模块（通过modules元素），但那些被聚合的模块不知道这个聚合模块的存在。<br>&amp;emsp;&amp;emsp;对于继承关系的父 POM 来说，它不知道哪些子模块继承于它，但那些子模块都必须知道自己的父 POM 是什么。<br>&amp;emsp;&amp;emsp;在实际项目中，大家会发现一个 pom 即是聚合 pom，又是父 pom，这么做主要是为了方便。</p><h4 id="Maven中的依赖传递"><a href="#Maven中的依赖传递" class="headerlink" title="Maven中的依赖传递"></a>Maven中的依赖传递</h4><p>&amp;emsp;&amp;emsp;在Maven中，依赖是可以传递的，就是说假设存在三个项目，分别是项目A，项目B以及项目C，假设C依赖于B，B依赖于A，那么我们可以根据Maven项目依赖的特征不难推出项目C也依赖于A</p><p><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/maven/index.htm">Maven Tutorial</a><br><a target="_blank" rel="noopener" href="https://maven.apache.org/#welcome-to-apache-maven">Maven – Welcome to Apache Maven</a><br><a target="_blank" rel="noopener" href="https://dunwu.github.io/java-tutorial/javatool/build/maven/">Maven 教程 | JAVA-TUTORIAL)</a></p><hr><h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL\TLS协议"></a>SSL\TLS协议</h3><p>Secure Socket Layer：安全套接字<br>Tranport Layer Secure：传输层安全</p><hr><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>&amp;emsp;&amp;emsp;从传统的客户端-服务器的架构演变到分布式架构，中间件应运而生。</p><p>&amp;emsp;&amp;emsp;从架构的纵向角度看，位于各类应用&#x2F;服务与操作系统&#x2F;数据库系统以及其他系统软件之间，主要解决分布式环境下数据传输、数据访问、应用调度、系统构建和系统集成、流程管理等问题，是分布式环境下支撑应用开发、运行和集成的平台，能够实现系统之间的互联互通，帮助用户高效开发应用软件。</p><p>中间件发展至今分为几类：</p><blockquote><ul><li><p>基础中间件</p><ul><li><p><strong>交易中间件:</strong><br>是面向对象技术与分布式计算技术结合的产物，其高效地传递交易（事务）请求，协调事务的各个分支，保证事务的完整性，调度应用程序的运行，实现整个系统运行的高效性。交易中间件适用于联机交易系统，如银行业务系统、订票系统等，在金融、财税、电信等行业中得到广泛落地。</p></li><li><p><strong>消息中间件:</strong><br>解决了分布式计算环境下多个子系统间的消息通信问题。其建立网络异步通信的通道，实现不同或同一计算机系统的应用通信，为网络环境下分布式应用系统的开发和运行提供灵活、易用的支撑平台，通常用来在各个系统或者组件间发送消息数据。消息队列是消息中间件的一种实现方式。</p></li><li><p><strong>应用服务器中间件:</strong><br>主要应用于Web系统，位于客户浏览器和数据库之间，其主要作用为把商业逻辑（应用）曝露给客户端，同时为商业逻辑（应用）提供运行平台和系统服务，并管理对数据库的访问。应用服务器中间件为Web系统下的应用开发者提供了开发工具和运行平台。</p></li></ul></li><li><p>集成中间件<br>伴随着网络技术的进一步发展，基础中间件难以解决业务跨部门、跨企业的互联互通问题，集成中间件应运而生，主要基于面向服务（Service Oriented Architecture，SOA）架构。在SOA架构下，Web Services是一种具体实现方式，所有具备价值的IT资源不论新旧，均能成为随取随用的IT资产，并将各种服务快速整合并开发为组合式应用。</p><ul><li><p><strong>企业服务总线ESB</strong><br>其基于消息通信、智能路由、数据转换等技术，支持各种异构软件及业务模块以服务化方式进行通信，是一种综合的集成中间件。</p></li><li><p><strong>物联网中间件</strong></p></li><li><p><strong>工作流中间件</strong></p></li><li><p><strong>其他各类型中间件</strong></p></li></ul></li></ul></blockquote><hr><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>Explanation:<br>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications.<br>链接:<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index">Zookeeper wiki</a></p><hr><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>Apache ActiveMQ® is the most popular open source, multi-protocol, Java-based message broker.</p><hr><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><hr><h3 id="序列注册中心"><a href="#序列注册中心" class="headerlink" title="序列注册中心"></a>序列注册中心</h3><hr><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><hr><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><hr><h3 id="服务之间的通信过程（eagle平台）"><a href="#服务之间的通信过程（eagle平台）" class="headerlink" title="服务之间的通信过程（eagle平台）"></a>服务之间的通信过程（eagle平台）</h3><h4 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h4><p>&amp;emsp;&amp;emsp;报文、通讯组件、任务处理组件</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>&amp;emsp;&amp;emsp;两个服务接口之间的通信是以报文为载体的。<br>以x接口为例：接口调用者发送报文给接口，接口处理完后仍以该报文为载体返回结果。对x接口而言，该报文称为in报文；对调用者而言，该报文称为out报文。</p><hr><h3 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h3><h4 id="交易类型"><a href="#交易类型" class="headerlink" title="交易类型"></a>交易类型</h4><h4 id="账户类型"><a href="#账户类型" class="headerlink" title="账户类型"></a>账户类型</h4><ul><li>真实账户</li><li>虚拟账户<h4 id="批量开户"><a href="#批量开户" class="headerlink" title="批量开户"></a>批量开户</h4></li></ul><hr><h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p><strong>JUnit</strong> is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unit_testing">unit testing</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_framework">framework</a> for the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java programming language</a>. JUnit has been important in the development of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Test-driven_development">test-driven development</a>, and is one of a family of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unit_testing">unit testing</a> frameworks which is collectively known as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/XUnit">xUnit</a> that originated with <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SUnit">SUnit</a>.</p><p>JUnit is linked as a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JAR_(file_format)">JAR</a> at compile-time. The latest version of the framework, JUnit 5, resides under package <code>org.junit.jupiter</code>. Previous versions JUnit 4 and JUnit 3 were under packages <code>org.junit</code> and <code>junit.framework</code>, respectively.</p><p>A research survey performed in 2013 across 10,000 Java projects hosted on GitHub found that JUnit (in a tie with <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SLF4J">slf4j-api</a>), was the most commonly included external library. Each library was used by 30.7% of projects.</p><p>JUnit是一个开发源代码的Java测试框架，用于编写和运行可重复的测试。它是用于单元测试框架体系xUnit的一个实例（用于java语言）。它包括以下特性：</p><p>1、用于测试期望结果的断言（Assertion）</p><p>2、用于共享共同测试数据的测试工具</p><p>3、用于方便的组织和运行测试的测试套件</p><p>4、图形和文本的测试运行器</p><p>JUnit最初是由Erich Gamma（GoF之一）和Kent Beck（xp和refactor的先驱之一）编写的.</p><p>需要说明的是junit一般是用来进行单元测试的，因此需要了解被测试代码的内部结构（即所谓的白盒测试），另外junit是在xp编程和重构 （refactor）中被极力推荐使用的工具，因为在实现自动单元测试的情况下可以大大的提高开发的效率，但是实际上编写测试代码也是需要耗费很多的时间 和精力的，那么使用这个东东好处到底在哪里呢？笔者认为是这样的：</p><p>1、对于xp编程而言，要求在编写代码之前先写测试，这样可以强制 你在写代码之前好好的思考代码（方法）的功能和逻辑，否则编写的代码很不稳定，那么你需要同时维护测试代码和实际代码，这个工作量就会大大增加。因此在 xp编程中，基本过程是这样的：构思－》编写测试代码－》编写代码－》测试，而且编写测试和编写代码都是增量式的，写一点测一点，在编写以后的代码中如果 发现问题可以较块的追踪到问题的原因，减小回归错误的纠错难度</p><p>2、对于重构而言，其好处和xp编程中是类似的，因为重构也是要求改一点测一点，减少回归错误造成的时间消耗。</p><p>3、 对于非以上两种情况，我们在开发的时候使用junit写一些适当的测试也是有必要的，因为一般我们也是需要编写测试的代码的，可能原来不是使用的 junit，如果使用junit，而且针对接口（方法）编写测试代码会减少以后的维护工作，例如以后对方法内部的修改（这个就是相当于重构的工作了）。另 外就是因为junit有断言功能，如果测试结果不通过会告诉我们那个测试不通过，为什么，而如果是想以前的一般做法是写一些测试代码看其输出结果，然后再 由自己来判断结果使用正确，使用junit的好处就是这个结果是否正确的判断是它来完成的，我们只需要看看它告诉我们结果是否正确就可以了，在一般情况下 会大大提高效率。</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ArduousBonze/article/details/2452283">原文链接</a></p><h3 id="Public-cloud（IaaS、PaaS、SaaS）"><a href="#Public-cloud（IaaS、PaaS、SaaS）" class="headerlink" title="Public cloud（IaaS、PaaS、SaaS）"></a>Public cloud（IaaS、PaaS、SaaS）</h3><h4 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h4><p>With <strong>IaaS</strong>, a provider supplies the basic compute, storage and networking infrastructure along with the <a target="_blank" rel="noopener" href="https://searchservervirtualization.techtarget.com/definition/hypervisor">hypervisor</a> – the virtualization layer. Users must then create <a target="_blank" rel="noopener" href="https://searchservervirtualization.techtarget.com/definition/virtual-machine">virtual machines</a>, install operating systems, support applications and data, and handle all of the configuration and management associated with those tasks. Examples of IaaS services are DigitalOcean, AWS and Google Compute Engine (GCE).</p><h4 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h4><p>With <strong>PaaS</strong>, a provider offers more of the application <a target="_blank" rel="noopener" href="https://whatis.techtarget.com/definition/stack">stack</a> than IaaS solutions, adding operating systems, middleware (such as databases) and other runtimes into the cloud environment. PaaS products include AWS Elastic Beanstalk and Google App Engine.</p><p><a target="_blank" rel="noopener" href="https://searchcloudcomputing.techtarget.com/definition/Platform-as-a-Service-PaaS">PaaS(platform as a service)</a></p><h4 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h4><p>With <strong>SaaS</strong>, a provider offers an entire application stack. Users simply log in and use the application that runs completely on the provider’s infrastructure. Typically, SaaS applications are completely accessible via internet web browser. SaaS providers manage all IT resources. Examples of SaaS include Salesforce, Dropbox and Google Workspace.</p><h3 id="VBScript"><a href="#VBScript" class="headerlink" title="VBScript"></a>VBScript</h3><h4 id="一些基本语法"><a href="#一些基本语法" class="headerlink" title="一些基本语法"></a>一些基本语法</h4><p>注释：在要注释的语句前加上 ‘ 即可</p><h4 id="执行bat批处理的两种方式"><a href="#执行bat批处理的两种方式" class="headerlink" title="执行bat批处理的两种方式"></a>执行bat批处理的两种方式</h4><ol><li><p>使用wscript的run方法</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> oShell,batFile</span><br><span class="line">batFile=<span class="string">&quot;你的脚本.bat&quot;</span></span><br><span class="line"><span class="keyword">Set</span> oShell = <span class="built_in">CreateObject</span>(<span class="string">&quot;wscript.shell&quot;</span>)</span><br><span class="line">oShell.run(batFile,<span class="number">0</span>,ture) <span class="comment">&#x27; 第二个参数 0的意思是隐藏cmd界面，第三个参数是是否等待执行完成</span></span><br></pre></td></tr></table></figure></li><li><p>使用wscript的exec方法</p><blockquote><p>exec方法可以获取控制台输出信息和控制台错误信息</p></blockquote></li></ol><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.51cto.com/alany/1568375">WScript.Shell对象的 run()和exec()函数使用详解</a></p><h4 id="VB的界面设计"><a href="#VB的界面设计" class="headerlink" title="VB的界面设计"></a>VB的界面设计</h4><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建用户:create user &#x27;admin&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;</span><br><span class="line">查看及修改密码策略:</span><br><span class="line">	#查看密码策略</span><br><span class="line">	show variables like &#x27;%validate_password.policy%&#x27;;</span><br><span class="line">	show variables like &#x27;%validate_password.length%&#x27;;</span><br><span class="line">	#修改密码策略</span><br><span class="line">	set global validate_password.policy=0;  #设置为弱口令</span><br><span class="line">	set global validate_password.length=6;  #密码最小长度为6</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database db_example; 									-- Creates the new database</span><br><span class="line">mysql&gt; create user &#x27;springuser&#x27;@&#x27;%&#x27; identified by &#x27;ThePassword&#x27;; 	-- Creates the user</span><br><span class="line">mysql&gt; grant all on db_example.* to &#x27;springuser&#x27;@&#x27;%&#x27;; 				-- Gives all privileges to the new user on the newly created database</span><br></pre></td></tr></table></figure><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>Advanced Message Queue Protocol</p><h4 id="消息队列的历史"><a href="#消息队列的历史" class="headerlink" title="消息队列的历史"></a>消息队列的历史</h4><p>了解一件事情的来龙去脉，将不会对它感到神秘。让我们来看看消息队列（Message Queue）这项技术的发展历史。</p><p>Message Queue的需求由来已久，80年代最早在金融交易中，高盛等公司采用Teknekron公司的产品，当时的Message queuing软件叫做：the information bus（TIB）。 TIB被电信和通讯公司采用，路透社收购了Teknekron公司。之后，IBM开发了MQSeries，微软开发了Microsoft Message Queue（MSMQ）。这些商业MQ供应商的问题是厂商锁定，价格高昂。2001年，Java Message queuing试图解决锁定和交互性的问题，但对应用来说反而更加麻烦了。</p><p>于是2004年，摩根大通和iMatrix开始着手Advanced Message Queuing Protocol （AMQP）开放标准的开发。2006年，AMQP规范发布。2007年，Rabbit技术公司基于AMQP标准开发的RabbitMQ 1.0 发布。</p><p>目前RabbitMQ的最新版本为3.5.7，基于AMQP 0-9-1。<br>RabbitMQ采用Erlang语言开发。Erlang语言由Ericson设计，专门为开发concurrent和distribution系统的一种语言，在电信领域使用广泛。OTP（Open Telecom Platform）作为Erlang语言的一部分，包含了很多基于Erlang开发的中间件／库／工具，如mnesia／SASL，极大方便了Erlang应用的开发。OTP就类似于Python语言中众多的module，用户借助这些module可以很方便的开发应用。</p><h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><ul><li><p><strong>Broker</strong>: 接收和分发消息的应用，RabbitMQ Server就是Message Broker。</p></li><li><p><strong>Virtual host</strong>: 出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange／queue等。</p></li><li><p><strong>Connection</strong>: publisher／consumer和broker之间的TCP连接。断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或broker服务出现问题。</p></li><li><p><strong>Channel</strong>: 如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。</p></li><li><p><strong>Exchange</strong>: message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</p></li><li><p><strong>Queue</strong>: 消息最终被送到这里等待consumer取走。一个message可以被同时拷贝到多个queue中。</p></li><li><p><strong>Binding</strong>: exchange和queue之间的虚拟连接，binding中可以包含routing key。Binding信息被保存到exchange中的查询表中，用于message的分发依据。</p><p><img src="https://gitee.com/green-wine/myProjects/raw/master/MyDocs/drawio/MQ%E6%A6%82%E5%BF%B5%E5%9B%BE.svg" alt="概念图"></p></li></ul><h4 id="典型的“生产-x2F-消费”消息模型"><a href="#典型的“生产-x2F-消费”消息模型" class="headerlink" title="典型的“生产&#x2F;消费”消息模型"></a>典型的“生产&#x2F;消费”消息模型</h4><p>生产者发送消息到broker server（RabbitMQ）。在Broker内部，用户创建Exchange／Queue，通过Binding规则将两者联系在一起。Exchange分发消息，根据类型／binding的不同分发策略有区别。消息最后来到Queue中，等待消费者取走。</p><h4 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h4><p>Exchange有多种类型，最常用的是Direct／Fanout／Topic三种类型。</p><p><strong>Direct</strong> （point 2 point 点对点模式）<br>Message中的“routing key”如果和Binding中的“binding key”一致， Direct exchange则将message发到对应的queue中。</p><p><strong>Fanout</strong> （多播模式）<br>每个发到Fanout类型Exchange的message都会分到所有绑定的queue上去。</p><p><strong>Topic</strong> （发布-订阅模式）<br>根据routing key，及通配规则，Topic exchange将分发到目标queue中。</p><p>Routing key中可以包含两种通配符，类似于正则表达式：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“<span class="comment">#”通配任何零个或多个word</span></span><br><span class="line">“*”通配任何单个<span class="built_in">word</span></span><br></pre></td></tr></table></figure><p>这里也推荐给想要了解RabbitMQ的同学一个网站，<a target="_blank" rel="noopener" href="http://tryrabbitmq.com/">RabbitMQ Simulator</a> ，它提供在线RabbitMQ 模拟器，可以帮助理解Exchange／queue／binding概念。</p><h3 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h3><p><strong>适用于Linux的Windows子系统</strong>（英语：Windows Subsystem for Linux，简称<strong>WSL</strong>）是一个为在Windows 10和Windows Server 2019上能够原生运行Linux二进制可执行文件（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%9F%B7%E8%A1%8C%E8%88%87%E5%8F%AF%E9%8F%88%E6%8E%A5%E6%A0%BC%E5%BC%8F">ELF</a>格式）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%BC%E5%AE%B9%E5%B1%82">兼容层</a>。</p><p>WSL提供了一个由微软开发的Linux兼容的内核接口（不包含Linux内核代码），然后可以在其上运行GNU用户空间，例如Ubuntu，openSUSE，SUSE Linux Enterprise Server，Debian和Kali Linux。这样的用户空间可能包含Bash shell和命令语言，使用本机GNU&#x2F;Linux命令行工具（sed，awk等），编程语言解释器（Ruby，Python等），甚至是图形应用程序（使用主机端的X窗口系统）。</p><h3 id="URI、URN、URL"><a href="#URI、URN、URL" class="headerlink" title="URI、URN、URL"></a>URI、URN、URL</h3><p>A URI, which stands for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Uniform Resource Identifier</a>, is a sequence of characters that identifies a web resource by location, name, or both in the <a target="_blank" rel="noopener" href="https://webfoundation.org/about/vision/history-of-the-web/">World Wide Web</a>. It is a method that allows for the uniform identification of the resources. Basically, there are two types of URIs: URNs (Uniform Resource Names) and URLs (Uniform Resource Locators).</p><h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><p>A <strong>domain-specific language</strong> (<strong>DSL</strong>) is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_language">computer language</a> specialized to a particular application <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Domain_(software_engineering)">domain</a>. This is in contrast to a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/General-purpose_language">general-purpose language</a> (GPL), which is broadly applicable across domains. There are a wide variety of DSLs, ranging from widely used languages for common domains, such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HTML">HTML</a> for web pages, down to languages used by only one or a few pieces of software, such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MUSH">MUSH</a> soft code. DSLs can be further subdivided by the kind of language, and include domain-specific <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Markup_language"><em>markup</em> languages</a>, domain-specific <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Modeling_language"><em>modeling</em> languages</a> (more generally, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Specification_language">specification languages</a>), and domain-specific <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Programming_language"><em>programming</em> languages</a>. Special-purpose computer languages have always existed in the computer age, but the term “domain-specific language” has become more popular due to the rise of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Domain-specific_modeling">domain-specific modeling</a>. Simpler DSLs, particularly ones used by a single application, are sometimes informally called <strong>mini-languages</strong>.</p><p>The line between general-purpose languages and domain-specific languages is not always sharp, as a language may have specialized features for a particular domain but be applicable more broadly, or conversely may in principle be capable of broad application but in practice used primarily for a specific domain. For example, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Perl">Perl</a> was originally developed as a text-processing and glue language, for the same domain as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/AWK">AWK</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shell_script">shell scripts</a>, but was mostly used as a general-purpose programming language later on. By contrast, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/PostScript">PostScript</a> is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Turing_complete">Turing complete</a> language, and in principle can be used for any task, but in practice is narrowly used as a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Page_description_language">page description language</a>.</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://qingjiu.life/%E6%9A%82%E5%AD%98/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="青酒"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青酒的代码馆"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%9A%82%E5%AD%98/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0.html" class="post-title-link" itemprop="url">未命名</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-14 08:47:52" itemprop="dateCreated datePublished" datetime="2022-03-14T08:47:52+08:00">2022-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-03-10 11:31:43" itemprop="dateModified" datetime="2022-03-10T11:31:43+08:00">2022-03-10</time></span></div></header><div class="post-body" itemprop="articleBody"></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="青酒" src="/images/avatar.png"><p class="site-author-name" itemprop="name">青酒</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">27</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/codinglibrary" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;codinglibrary" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:hobart_lh@163.com" title="E-Mail → mailto:hobart_lh@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">青酒</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="20" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r,a=document.getElementsByTagName("link");if(0<a.length)for(i=0;i<a.length;i++)"canonical"==a[i].rel.toLowerCase()&&a[i].href&&(e=a[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e=e||window.location.href,window,n=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(n)||(o="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(o+="?r="+encodeURIComponent(document.referrer),n&&(o+="&l="+n)):n&&(o+="?l="+n),(new Image).src=o)}()</script><script>if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }</script></body></html>